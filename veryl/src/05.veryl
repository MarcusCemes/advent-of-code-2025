/// Day 05: Range Merger
///
/// Parses ranges (e.g., "3-5", "10-14") from input and merges overlapping ranges,
/// then counts total coverage.
///
/// IMPORTANT: This solution requires BYTES to be large enough to encompass an entire
/// line at once (processes one line per cycle). The decoder assumes the full range
/// specification (e.g., "123-456\n") fits within a single BYTES-wide input buffer.
/// With the default BYTES=32 in the decoder, lines up to 32 characters are supported.
pub module Day05 #(
    param BYTES: u32 = 32,
) (
    clk: input clock,
    rst: input reset,

    i_data     : input  logic<BYTES, 8>,
    i_available: input  logic<IDX_BITS>,
    o_consumed : output logic<IDX_BITS>,
    o_finished : output logic          ,
    o_answer   : output logic<64>      ,
) {
    const IDX_BITS: u32 = $clog2(BYTES + 1);

    var decoder_end     : logic<64>;
    var decoder_finished: logic    ;
    var decoder_start   : logic<64>;
    var decoder_valid   : logic    ;
    var solver_busy     : logic    ;

    inst decoder: Day05Decoder (
        clk                          ,
        rst                          ,
        i_available                  ,
        i_busy     : solver_busy     ,
        i_data                       ,
        o_consumed                   ,
        o_end      : decoder_end     ,
        o_finished : decoder_finished,
        o_start    : decoder_start   ,
        o_valid    : decoder_valid   ,
    );

    inst solver: Day05Solver (
        clk                         ,
        rst                         ,
        i_end     : decoder_end     ,
        i_finished: decoder_finished,
        i_start   : decoder_start   ,
        i_valid   : decoder_valid   ,
        o_answer                    ,
        o_busy    : solver_busy     ,
        o_finished                  ,
    );
}

module Day05Decoder #(
    param BYTES : u32 = 32,
    param DIGITS: u32 = 15,
) (
    clk: input clock,
    rst: input reset,

    i_available: input logic<IDX_BITS>,
    i_busy     : input logic          ,
    i_data     : input logic<BYTES, 8>,

    o_consumed: output logic<IDX_BITS>,
    o_end     : output logic<64>      ,
    o_finished: output logic          ,
    o_start   : output logic<64>      ,
    o_valid   : output logic          ,
) {
    const DIGIT_BITS: u32 = $clog2(DIGITS);
    const DIGIT_LEN : u32 = $clog2(DIGITS + 1);
    const IDX_BITS  : u32 = $clog2(BYTES + 1);

    enum State: logic {
        Parse,
        Done,
    }

    var state: State;

    var dash_index   : logic<IDX_BITS>;
    var dash_match   : logic          ;
    var newline_index: logic<IDX_BITS>;
    var newline_match: logic          ;

    const DATA_IDX_BITS: u32                  = $clog2(BYTES);
    var index_a      : logic<DATA_IDX_BITS>;
    var index_b      : logic<DATA_IDX_BITS>;

    var n_digits_a: logic<DIGIT_LEN>;
    var n_digits_b: logic<DIGIT_LEN>;

    var digits_a: logic<DIGITS, 4>;
    var digits_b: logic<DIGITS, 4>;

    inst dash: FindDelimiter #(
        DELIMITER: 8'h2D, // ASCII '-'
    ) (
        i_available            ,
        i_data                 ,
        o_index    : dash_index,
        o_match    : dash_match,
    );

    inst newline: FindDelimiter #(
        DELIMITER: 8'h0A, // ASCII '\n'
    ) (
        i_available               ,
        i_data                    ,
        o_index    : newline_index,
        o_match    : newline_match,
    );

    inst digits_extractor_a: DigitsExtractor #(
        BYTES   ,
        DIGITS  ,
    ) (
        i_data                 ,
        i_digits   : n_digits_a,
        i_lsb_index: index_a   ,
        o_value    : digits_a  ,
    );

    inst digits_extractor_b: DigitsExtractor #(
        BYTES   ,
        DIGITS  ,
    ) (
        i_data                 ,
        i_digits   : n_digits_b,
        i_lsb_index: index_b   ,
        o_value    : digits_b  ,
    );

    inst combiner_a: DigitCombiner #(
        DIGITS  ,
    ) (
        i_digits: digits_a,
        o_value : o_start ,
    );

    inst combiner_b: DigitCombiner #(
        DIGITS  ,
    ) (
        i_digits: digits_b,
        o_value : o_end   ,
    );

    always_ff {
        if_reset {
            state = State::Parse;

        } else {
            if state == State::Parse && newline_match && newline_index == 0 {
                state = State::Done;
            }
        }
    }

    // Determine number of digits and their positions
    always_comb {
        n_digits_a = 0;
        n_digits_b = 0;

        index_a = 0;
        index_b = 0;

        let dash_digits: logic<DIGIT_LEN> = dash_index as DIGIT_LEN;

        if dash_match {
            n_digits_a = dash_digits;
            n_digits_b = i_available as DIGIT_LEN;

            if dash_index != 0 {
                index_a = dash_index[DATA_IDX_BITS - 1:0] - 1 as DATA_IDX_BITS;
            }

            if newline_match {
                n_digits_b = newline_index as DIGIT_LEN;

                if newline_index != 0 {
                    index_b = newline_index[DATA_IDX_BITS - 1:0] - 1 as DATA_IDX_BITS;
                }
            }

            // n_digits_b = n_digits_b - dash_index - 1
            n_digits_b -= dash_digits - 1 as DIGIT_LEN;
        }
    }

    // Output signals
    always_comb {
        o_consumed = 0;
        o_finished = state == State::Done;
        o_valid    = !o_finished && newline_match && dash_match;

        if !i_busy && !o_finished && newline_match {
            o_consumed = newline_index + 1;
        }
    }
}

/// Merges overlapping ranges and counts total coverage.
/// Maintains up to 128 disjoint ranges in parallel arrays with occupancy bitmask.
module Day05Solver (
    clk: input clock,
    rst: input reset,

    i_end     : input logic<64>,
    i_finished: input logic    ,
    i_start   : input logic<64>,
    i_valid   : input logic    ,

    o_answer  : output logic<64>,
    o_busy    : output logic    ,
    o_finished: output logic    ,
) {
    const MAX_RANGES: u32 = 128;

    enum State: logic<3> {
        Idle,
        ScanOverlap,
        MergeOne,
        FindSlot,
        Insert,
        CountInit,
        CountScan,
        Done,
    }

    var state: State;

    var ranges_start: logic<64>         [MAX_RANGES];
    var ranges_end  : logic<64>         [MAX_RANGES];
    var occupied    : logic<MAX_RANGES>             ;

    var cur_start: logic<64>        ;
    var cur_end  : logic<64>        ;
    var scan_mask: logic<MAX_RANGES>;

    var overlap_mask      : logic<MAX_RANGES>;
    var first_overlap_idx : logic<7>         ;
    var has_overlap       : logic            ;
    var first_empty_idx   : logic<7>         ;
    var has_empty         : logic            ;
    var first_occupied_idx: logic<7>         ;
    var has_occupied      : logic            ;
    var count_mask        : logic<MAX_RANGES>;
    var answer            : logic<64>        ;

    // Overlap detection: ranges overlap or touch if end1+1 >= start2 AND end2+1 >= start1
    always_comb {
        for i: u32       in 0..MAX_RANGES {
            let slot_end_plus1   : logic<64> = ranges_end[i] + 1;
            let cur_end_plus1    : logic<64> = cur_end + 1;
            let overlaps_or_touch: logic     = (slot_end_plus1 >= cur_start) && (cur_end_plus1 >= ranges_start[i]);
            overlap_mask[i]   = occupied[i] && scan_mask[i] && overlaps_or_touch;
        }
    }

    // Priority encoder: first overlapping slot
    always_comb {
        first_overlap_idx = 0;
        has_overlap       = 0;
        for i: u32 in 0..MAX_RANGES {
            if overlap_mask[i] && !has_overlap {
                first_overlap_idx = i[6:0];
                has_overlap       = 1;
            }
        }
    }

    // Priority encoder: first empty slot
    always_comb {
        first_empty_idx = 0;
        has_empty       = 0;
        for i: u32 in 0..MAX_RANGES {
            if !occupied[i] && !has_empty {
                first_empty_idx = i[6:0];
                has_empty       = 1;
            }
        }
    }

    // Priority encoder: first occupied slot (for counting)
    always_comb {
        first_occupied_idx = 0;
        has_occupied       = 0;
        for i: u32 in 0..MAX_RANGES {
            if count_mask[i] && !has_occupied {
                first_occupied_idx = i[6:0];
                has_occupied       = 1;
            }
        }
    }

    always_ff {
        if_reset {
            state        = State::Idle;
            occupied     = 0;
            cur_start    = 0;
            cur_end      = 0;
            scan_mask    = 0;
            count_mask   = 0;
            answer       = 0;
            ranges_start = '{default: 0};
            ranges_end   = '{default: 0};

        } else {
            case state {
                State::Idle: {
                    if i_finished {
                        state = State::CountInit;

                    } else if i_valid {
                        cur_start = i_start;
                        cur_end   = i_end;
                        scan_mask = ~128'b0;
                        state     = State::ScanOverlap;
                    }
                }

                State::ScanOverlap: {
                    if has_overlap {
                        state = State::MergeOne;
                    } else {
                        state = State::FindSlot;
                    }
                }

                State::MergeOne: {
                    let idx: logic<7> = first_overlap_idx;

                    if ranges_start[idx] <: cur_start {
                        cur_start = ranges_start[idx];
                    }

                    if ranges_end[idx] >: cur_end {
                        cur_end = ranges_end[idx];
                    }

                    occupied[idx]  = 0;
                    scan_mask[idx] = 0;
                    state          = State::ScanOverlap;
                }

                State::FindSlot: {
                    if has_empty {
                        state = State::Insert;
                    } else {
                        state = State::Idle;
                    }
                }

                State::Insert: {
                    let idx              : logic<7> = first_empty_idx;
                    ranges_start[idx] = cur_start;
                    ranges_end[idx]   = cur_end;
                    occupied[idx]     = 1;
                    state             = State::Idle;
                }

                State::CountInit: {
                    count_mask = occupied;
                    answer     = 0;
                    state      = State::CountScan;
                }

                State::CountScan: {
                    if has_occupied {
                        let idx            : logic<7>  = first_occupied_idx;
                        let size           : logic<64> = ranges_end[idx] - ranges_start[idx] + 1;
                        answer          = answer + size;
                        count_mask[idx] = 0;

                    } else {
                        state = State::Done;
                    }
                }

                default: {}
            }
        }
    }

    always_comb {
        o_answer   = answer;
        o_busy     = state != State::Idle && state != State::Done;
        o_finished = state == State::Done;
    }
}

#[test(test_day_05)]
embed (inline) sv{{{
    `timescale 1ns/1ps

    module test_day_05;
        localparam string   FILENAME = "day_05.txt";
        localparam longint  EXPECTED = 64'd14;
        localparam longint  TIMEOUT  = 10000;

        localparam BYTES    = 32;
        localparam IDX_BITS = $clog2(BYTES + 1);

        logic clk, rst;
        longint cycle_count;

        logic [BYTES-1:0][7:0] i_data;
        logic [IDX_BITS-1:0] i_available;
        logic [IDX_BITS-1:0] o_consumed;
        logic o_finished;
        logic [63:0] o_answer;

        aoc_Day05 #(
            .BYTES(BYTES)
        ) dut (
            .clk(clk),
            .rst(rst),
            .i_data(i_data),
            .i_available(i_available),
            .o_consumed(o_consumed),
            .o_finished(o_finished),
            .o_answer(o_answer)
        );

        initial begin
            clk = 0;
            forever #0.5 clk = ~clk;
        end

        `include "aoc_tasks.svh"

        initial begin
            aoc_init();
            aoc_run_test(FILENAME, TIMEOUT, cycle_count);
            aoc_verify(EXPECTED, cycle_count);
            $finish;
        end
    endmodule
}}}
