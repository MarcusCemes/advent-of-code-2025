/// Algorithm:
/// - First line: find 'S' and set beams[cursor] = 1
/// - Subsequent lines: on '^' with beams[cursor] > 0:
///     beams[cursor-1] += timelines, beams[cursor] = 0, beams[cursor+1] += timelines
/// - Output: combinatorial sum of all beams
///
/// Hardware: 141 parallel 64-bit registers, single-cycle updates per byte
pub module Day07 #(
    param LINE_WIDTH: u32 = 141,
) (
    clk: input clock,
    rst: input reset,

    i_data : input logic<8>,
    i_valid: input logic   ,

    o_answer: output logic<64>,
    o_busy  : output logic    ,
    o_valid : output logic    ,
) {
    const CURSOR_BITS: u32 = $clog2(LINE_WIDTH);

    // Beam registers - each holds timeline count for that column
    var beams: logic<64> [LINE_WIDTH];

    // State
    var cursor    : logic<CURSOR_BITS>;
    var in_init   : logic             ; // true = first line (looking for 'S')
    var done      : logic             ;
    var prev_valid: logic             ;

    // Character classification
    let is_start   : logic = i_data == 8'h53; // 'S'
    let is_splitter: logic = i_data == 8'h5E; // '^'
    let is_newline : logic = i_data == 8'h0A; // '\n'

    // Combinatorial sum of all beams
    var beam_sum: logic<64>;

    always_comb {
        beam_sum = 0;

        for i: u32 in 0..LINE_WIDTH {
            beam_sum += beams[i];
        }
    }

    always_ff {
        if_reset {
            beams      = '{default: 0};
            cursor     = 0;
            in_init    = 1;
            done       = 0;
            prev_valid = 0;
        } else {
            prev_valid = i_valid;

            // Detect end of input
            if prev_valid && !i_valid {
                done = 1;
            }

            if i_valid && !done {
                // Cursor management
                if is_newline {
                    cursor  = 0;
                    in_init = 0; // First newline transitions out of init
                } else {
                    cursor = cursor + 1;
                }

                // Beam updates
                if in_init {
                    if is_start {
                        beams[cursor] = 1;
                    }
                } else {
                    if is_splitter && beams[cursor] >: 0 {
                        let timelines: logic<64> = beams[cursor];

                        beams[cursor - 1] = beams[cursor - 1] + timelines;
                        beams[cursor]     = 0;
                        beams[cursor + 1] = beams[cursor + 1] + timelines;
                    }
                }
            }
        }
    }

    assign o_answer = beam_sum;
    assign o_busy   = 0;
    assign o_valid  = done;
}
