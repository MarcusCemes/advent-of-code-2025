pub module Day07 #(
    param BYTES     : u32 = 32 ,
    param LINE_WIDTH: u32 = 141,
) (
    clk: input clock,
    rst: input reset,

    i_data     : input  logic<BYTES, 8>,
    i_available: input  logic<IDX_BITS>,
    o_consumed : output logic<IDX_BITS>,
    o_finished : output logic          ,
    o_answer   : output logic<64>      ,
) {
    const CURSOR_BITS: u32 = $clog2(LINE_WIDTH);
    const IDX_BITS   : u32 = $clog2(BYTES + 1);

    enum State: logic<2> {
        Init,
        Collect,
        Propagate,
        Done,
    }

    var beams     : logic<64> [LINE_WIDTH];
    var next_beams: logic<64> [LINE_WIDTH];

    var cursor: logic<CURSOR_BITS>;
    var state : State             ;

    var line     : logic<LINE_WIDTH>;
    var next_line: logic<LINE_WIDTH>;

    var s_eol_match: logic          ;
    var s_eol_index: logic<IDX_BITS>;

    var s_start_match: logic          ;
    var s_start_index: logic<IDX_BITS>;

    inst find_delimiter: FindDelimiter #(
        BYTES    : BYTES,
        DELIMITER: 8'h0A, // '\n'
    ) (
        i_data     : i_data     ,
        i_available: i_available,
        o_index    : s_eol_index,
        o_match    : s_eol_match,
    );

    inst find_start: FindDelimiter #(
        BYTES    : BYTES,
        DELIMITER: 8'h53, // 'S'
    ) (
        i_data     : i_data       ,
        i_available: i_available  ,
        o_index    : s_start_index,
        o_match    : s_start_match,
    );

    always_ff {
        if_reset {
            beams  = '{default: '0};
            cursor = '0;
            line   = '0;
            state  = State::Init;

        } else {
            case state {
                State::Init: {
                    if s_start_match {
                        let offset: logic<CURSOR_BITS> = s_start_index as CURSOR_BITS;

                        beams[cursor + offset] = 1;
                    }

                    if s_eol_match {
                        cursor = 0;
                        state  = State::Collect;

                    } else {
                        cursor += i_available as CURSOR_BITS;
                    }
                }

                State::Collect: {
                    line = next_line;

                    if s_eol_match || i_available != BYTES as IDX_BITS {
                        cursor = 0;
                        state  = State::Propagate;

                    } else {
                        cursor += i_available as CURSOR_BITS;
                    }
                }

                State::Propagate: {
                    beams = next_beams;
                    line  = '0;

                    if i_available == 0 {
                        state = State::Done;
                    } else {
                        state = State::Collect;
                    }

                }

                State::Done: {}
            }
        }
    }

    // Compute next beams
    always_comb {
        next_beams = beams;

        for i: u32 in 0..LINE_WIDTH {
            if line[i] == '1 {
                next_beams[i] = 0;

                if i != 0 {
                    next_beams[i - 1] += beams[i];
                }

                if i != LINE_WIDTH - 1 {
                    next_beams[i + 1] += beams[i];
                }
            }
        }

    }

    // Compute next line
    always_comb {
        next_line = line;

        for i: u32 in 0..BYTES {

            var enabled: logic;

            let offset: logic<CURSOR_BITS> = i as CURSOR_BITS;

            enabled = i_data[i] == 8'h5E; // '^'

            if s_eol_match && i >: s_eol_index {
                enabled = 0;
            }

            if enabled {
                next_line[cursor + offset] = 1;
            }
        }
    }

    // Compute the answer
    always_comb {
        o_answer = '0;

        if state == State::Done {
            for j: u32 in 0..LINE_WIDTH {
                o_answer += beams[j];
            }
        }
    }

    // Output signals
    always_comb {
        o_consumed = i_available;
        o_finished = state == State::Done;

        if s_eol_match {
            o_consumed = s_eol_index + 1;
        }

        if state != State::Init && state != State::Collect {
            o_consumed = 0;
        }
    }
}
